<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Literature Review &amp; Project Overview ‚Äì Geolife Daily Mobility</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-b4f4d60cfbc3b1e3dbcd7f2eeb7587ea.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar docked quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./LR.html">Analysis</a></li><li class="breadcrumb-item"><a href="./LR.html">Overview</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-center sidebar-header">
      <a href="./index.html" class="sidebar-logo-link">
      </a>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Analysis</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./LR.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Data Cleaning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Notebook 1 ‚Äì Data cleaning</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./by action.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Notebook 2 ‚Äì Trips by action</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./verification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Notebook 3 ‚Äì Cross-user verification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./conclusion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Findings and conclusion</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#what-is-epr" id="toc-what-is-epr" class="nav-link active" data-scroll-target="#what-is-epr">1. What is EPR?</a></li>
  <li><a href="#data-processing-from-raw-gps-to-homehome-trips" id="toc-data-processing-from-raw-gps-to-homehome-trips" class="nav-link" data-scroll-target="#data-processing-from-raw-gps-to-homehome-trips">2. Data Processing: From Raw GPS to Home‚ÄìHome Trips</a></li>
  <li><a href="#trip-level-behaviour-within-a-single-user" id="toc-trip-level-behaviour-within-a-single-user" class="nav-link" data-scroll-target="#trip-level-behaviour-within-a-single-user">3. Trip-level behaviour within a single user</a></li>
  <li><a href="#cross-user-comparison-pca-and-clustering-of-epr-profiles" id="toc-cross-user-comparison-pca-and-clustering-of-epr-profiles" class="nav-link" data-scroll-target="#cross-user-comparison-pca-and-clustering-of-epr-profiles">4. Cross-User Comparison: PCA and Clustering of EPR Profiles</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./LR.html">Analysis</a></li><li class="breadcrumb-item"><a href="./LR.html">Overview</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Literature Review &amp; Project Overview</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>This project uses high-resolution Geolife GPS trajectories to examine everyday mobility as a sequence of discrete visits, trips, and exploration decisions.<br>
The analysis is structured into five Jupyter notebooks.</p>
<section id="what-is-epr" class="level3">
<h3 class="anchored" data-anchor-id="what-is-epr">1. What is EPR?</h3>
<p>We examine everyday movement as a balance between revisiting familiar places and exploring new ones. In behavioral terms, most people follow habitual travel routines (e.g., home‚Äìwork‚Äìhome) yet occasionally deviate to novel destinations. This ‚Äúexploit vs.&nbsp;explore‚Äù trade-off can be framed by an Exploration‚ÄìPreferencing Ratio (EPR): a higher EPR means more exploration of new sites relative to returning to known ones. Conceptually, EPR is analogous to the exploration-and-preferential-return model in human mobility research, in which at each move an agent either visits a new location or returns to a past one (Pappalardo, Rinzivillo, &amp; Simini, 2016; Song, Koren, Wang, &amp; Barab√°si, 2010). Large-scale visitation patterns have been shown to arise from EPR-like dynamics in empirical data (Schl√§pfer et al., 2021; Song, Qu, Blumm, &amp; Barab√°si, 2010).</p>
<p>In mobility data, we treat EPR operationally as the ratio of novel stops to repeated stops. For example, if a trip includes three previously unvisited stops (exploration) and one repeated stop, the person‚Äôs trip-level EPR would be 3:1, indicating exploratory behavior. In our context, we adapt this idea to individual GPS trajectories by explicitly labelling each stop as either ‚ÄúPv‚Äù (previously visited) or ‚ÄúPn‚Äù (novel), and then modeling the patterns of Pv/Pn occurrences within trips.</p>
<p>In our data, we operationalize this by labelling each non-home stop as Pn (novel) if it is the first time the user has stopped at that particular location, or Pv (visited) if it falls at a location the user has visited before. Over a trip (home ‚Üí ‚Ä¶ ‚Üí home), we then summarize the trip‚Äôs exploratory tendency by, for example, the count of Pn stops or the ratio Pn/(Pv + Pn). A person‚Äôs overall EPR can be aggregated from their trips (e.g., average per-trip exploration rate).</p>
<p>This trip-focused EPR differs from classic probabilistic models (e.g., the EPR model of Song et al., 2010) in that we measure empirical behavior rather than impose a fixed probability of exploration (Song et al., 2010). Prior literature has examined related metrics: Pappalardo et al.&nbsp;(2015), for instance, show that individuals cluster into ‚Äúexplorers‚Äù (many new locations) or ‚Äúreturners‚Äù (few new locations) based on visit-count ratios. Our approach is similar in spirit but works at the granularity of trips and discrete stops.</p>
<p>We also draw on ecological ideas of foraging: just as people navigating information maximize an information-gain rate by choosing to explore ‚Äúnew patches‚Äù only when the expected gain outweighs the cost (Pirolli &amp; Card, 1999; Nielsen, 2019), travelers may implicitly weigh the novelty of a potential stop against its travel or time cost. We do not explicitly model that decision rule, but the EPR encapsulates its outcome. In short, EPR is the key behavioral concept linking individual choices of revisiting vs.&nbsp;exploring, and our goal is to measure it from trajectory data.</p>
</section>
<section id="data-processing-from-raw-gps-to-homehome-trips" class="level3">
<h3 class="anchored" data-anchor-id="data-processing-from-raw-gps-to-homehome-trips">2. Data Processing: From Raw GPS to Home‚ÄìHome Trips</h3>
<p>We apply the methodology to the Microsoft Geolife GPS dataset (184 users, multi-year GPS tracks; Zheng, Xie, &amp; Ma, 2010). We first convert raw GPS points into semantically meaningful visits (stay points). Using standard trajectory-mining techniques, consecutive GPS fixes that lie within a small spatial radius (e.g., ‚âà100 m) for a minimum dwell time (e.g., ‚âà10 minutes) are aggregated into a stay point (Zheng et al., 2009; Zheng, Zheng, Xie, &amp; Yang, 2010). Formally, a stay point is defined by a cluster of points ùëÉ={ùëùùëö,‚Ä¶,ùëùùëõ} such that the spatial diameter of ùëÉ is below a distance threshold and the time between ùëùùëö and ùëùùëõ exceeds a time threshold (Zheng et al., 2009). Each stay point is then assigned a centroid location and arrival/departure timestamps. This filters out GPS noise and moving intervals, yielding a sequence of places (visits) with clear stop durations.</p>
<p>Next, we identify each user‚Äôs home location as the most frequently visited place. Empirically, the single location with the highest visit frequency corresponds to home (Gonz√°lez et al., 2008; Pappalardo et al., 2015). This matches the intuition and prior work that the place of maximal stationary probability is likely home. After determining home, we segment the cleaned trajectory into home‚Äìhome trips: each trip begins when the user departs home and ends upon the next return home. In practice, we slide through the stay-point sequence, cutting a trip whenever the location is home, and discarding any days/trips that have no return. This yields a set of disjoint trips per user (e.g., morning commute, shopping trip), each being a sequence: Home ‚Üí Stop1 ‚Üí Stop2 ‚Üí ‚Ä¶ ‚Üí StopK ‚Üí Home. (Home appears only at the trip start and end; intermediate stops exclude home by definition.)</p>
<p>Within each trip, we then label every non-home stop as Pv or Pn. We maintain a running history of all places the user has visited so far (across all days). A stop is labeled Pn (novel) if its location did not appear earlier in that user‚Äôs history, and Pv (visited) if it matches a previously seen location. Home itself is always familiar (Pv). In this way, each trip is converted into a sequence of binary labels (Pv/Pn) along with durations and distances. The count of Pn stops in the trip (or fraction of stops that are Pn) serves as the empirical measure of that trip‚Äôs exploratory character, directly implementing our EPR concept.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="image/001.png" class="img-fluid figure-img"></p>
<figcaption>Notebook 1 overview</figcaption>
</figure>
</div>
</section>
<section id="trip-level-behaviour-within-a-single-user" class="level3">
<h3 class="anchored" data-anchor-id="trip-level-behaviour-within-a-single-user">3. Trip-level behaviour within a single user</h3>
<p>Given the trip sequences with Pv/Pn labels, we model two aspects of trip behavior per step.</p>
<p>First is the hazard of returning home (trip termination). We treat each trip as a discrete-time survival process: at each stop (time step) until the trip ends, there is a probability that the user returns home in the next step. Following Singer and Willett‚Äôs discrete-time survival framework, we fit a logistic hazard model in which the trip is ‚Äúexploded‚Äù into multiple rows, one per stop, with a binary outcome indicating whether the next step is Home (return = 1) or not (0) (Singer &amp; Willett, 1993). We then regress this outcome on covariates available at that step (for example, number of stops elapsed, time since departure, whether the last stop was novel, etc.). This yields a discrete-time hazard model of going home, capturing how trip continuation risk evolves with trip context. Conceptually, it answers questions like: given that I have visited X stops so far (perhaps including a new site), what is the probability I will head home next?</p>
<p>Second, we explicitly model the exploration tendency at each step. Here the binary outcome is whether the current stop is novel (Pn) versus familiar (Pv). We fit a logistic regression (or similar classification model) for ‚Äúexplore = 1‚Äù at each stop, using predictors such as trip length so far, time of day, day of week, distance from home, and so on. This regression tells us how the probability of visiting a new location depends on the trip‚Äôs progress and context. Equivalently, one can think of this as a trip-level ‚ÄúEPR regression‚Äù that predicts Pn vs.&nbsp;Pv for each stop.</p>
<p>In both models we include basic contextual controls (trip duration, step index) so that each user‚Äôs parameters reflect their intrinsic behavior rather than trivial mechanical factors. Fitting is done separately for each user so that everyone gets their own personalized hazard and exploration models. In practice we ensure users have enough trips to fit a model reasonably (e.g., ‚â•30 trips). The result of this step is, for each user, a vector of model coefficients (plus an intercept) summarizing their trip-termination and exploration behaviors.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="image/002.png" class="img-fluid figure-img"></p>
<figcaption>Notebook 2 overview</figcaption>
</figure>
</div>
</section>
<section id="cross-user-comparison-pca-and-clustering-of-epr-profiles" class="level3">
<h3 class="anchored" data-anchor-id="cross-user-comparison-pca-and-clustering-of-epr-profiles">4. Cross-User Comparison: PCA and Clustering of EPR Profiles</h3>
<p>Finally, we compare users in the space of these model-derived behaviors. Each user‚Äôs model yields a feature vector (e.g., [hazard intercept, hazard slope, exploration intercept, exploration slope, ‚Ä¶]) that encodes their tendency to explore and to return. Since this vector may be high-dimensional, we first apply principal components analysis (PCA) to reduce dimensionality and identify the main axes of behavioral variance. PCA reveals whether users vary along, for example, a ‚Äúhigh-exploration vs.&nbsp;high-preference for revisitation‚Äù spectrum or along other blended factors.</p>
<p>We then apply k-means clustering (with k chosen by silhouette or cross-validation criteria) to group users into behavioral phenotypes based on their PCA scores. Prior work has shown that clustering mobility patterns often yields well-separated groups defined by exploration intensity and travel range (Liao et al., 2019; Pappalardo et al., 2015; Zhao et al., 2021). In our case, the clustering identifies typical EPR/hazard profiles in the population‚Äîfor example, ‚Äúlocal explorers‚Äù (generally short trips but often to new places) versus ‚Äúlong-distance returners‚Äù (travel far but largely between the same hubs). We can then summarize each cluster by its mean EPR, radius of gyration, and similar indicators, and interpret it in behavioral terms.</p>
<p>Throughout, we ensure clarity of interpretation: model coefficients correspond to intuitive concepts (e.g., a large negative hazard intercept means trips end quickly; a large positive exploration slope might mean each additional stop reduces the chance of further exploration). By casting them into PCA space, we make it easier to describe major behavioral dimensions. Altogether, this pipeline‚Äîfrom raw GPS to stay points, from trips to Pv/Pn labeling, from trips to individualized discrete-time models, and from models to a population summary‚Äîcreates a coherent methodology for analyzing exploration versus revisitation in human mobility.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Geolife Daily Mobility</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Built with Quarto</p>
</div>
  </div>
</footer>




</body></html>